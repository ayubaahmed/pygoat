<!-- Custom CSS Modal for Security Fix -->
<div id="secureFixModal" class="custom-modal">
    <div class="modal-overlay"></div>
    <div class="modal-container">
        <div class="modal-header">
            <h2 class="modal-title">
                üõ°Ô∏è Security Fix for Cryptographic Failure
            </h2>
            <button type="button" class="close-btn" onclick="closeModal()">&times;</button>
        </div>
        <div class="modal-body">
            <div class="tabs-container">
                <div class="tab-buttons">
                    <!-- <button class="tab-btn active" onclick="showTab('vulnerability')">Vulnerability</button> -->
                    <button class="tab-btn active" style="font-weight: bold; font-size: 18px;" onclick="showTab('secure-code')">Secure Code</button>
                    <button class="tab-btn " style="font-weight: bold; font-size: 18px;" onclick="showTab('prevention')">Solution</button>
                </div>

                <div class="tab-content">
                    <div id="secure-code" class="tab-panel active">
                        <h4>Secure Implementation for Cryptographic Failure</h4>
                        <pre class="code-block"><code>
import os
import hashlib
import hmac
import secrets
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
import base64

class SecureCrypto:
    
    def hash_password(self, password: str) -> tuple[str, str]:
                
        # SECURE: PBKDF2 password hashing with salt
                
        salt = os.urandom(32)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,  # OWASP minimum
        )
        
        key = kdf.derive(password.encode())
        return base64.b64encode(key).decode(), base64.b64encode(salt).decode()
    
    def verify_password(self, password: str, stored_hash: str, salt: str) -> bool:
                
        # SECURE: Constant-time password verification
                
        try:
            salt_bytes = base64.b64decode(salt)
            stored_key = base64.b64decode(stored_hash)
            
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=salt_bytes,
                iterations=100000,
            )
            
            new_key = kdf.derive(password.encode())
            return hmac.compare_digest(stored_key, new_key)  # Timing attack safe
            
        except:
            return False
    
    def encrypt_data(self, data: str) -> tuple[str, str]:
                
        # SECURE: AES-256 authenticated encryption
                
        key = Fernet.generate_key()
        fernet = Fernet(key)
        encrypted = fernet.encrypt(data.encode())
        
        return base64.b64encode(encrypted).decode(), base64.b64encode(key).decode()
    
    def decrypt_data(self, encrypted_data: str, key: str) -> str:
        
        # SECURE: Authenticated decryption
        
        key_bytes = base64.b64decode(key)
        encrypted_bytes = base64.b64decode(encrypted_data)
        
        fernet = Fernet(key_bytes)
        return fernet.decrypt(encrypted_bytes).decode()
    
    def secure_token(self, length: int = 32) -> str:
                
        # SECURE: Cryptographically secure random token
                
        return secrets.token_urlsafe(length)
    
    def create_signature(self, data: str, secret: str) -> str:
                
        # SECURE: HMAC signature for integrity
                
        return hmac.new(
            secret.encode(),
            data.encode(),
            hashlib.sha256
        ).hexdigest()
    
    def verify_signature(self, data: str, signature: str, secret: str) -> bool:
        
        # SECURE: Timing attack safe verification
        
        expected = self.create_signature(data, secret)
        return hmac.compare_digest(signature, expected)</code></pre>
                    </div>

                    <div id="prevention" class="tab-panel">
                                <h4>Solution</h4>
                                <h4>Lab 1</h4>
                                <li>Given material --> some user id and hash</li> <br>
                                <p>[ step- 1 ] Identification of the hash</p>
                                
                                <li>the hash is 32 character long</li>
                                <li>most probably the hash is from MD* family which is pretty weak hash ( weak in the sense , it have hash collision )</li>
                                <li>we can use <a href="https://hashes.com/en/tools/hash_identifier" target="_blank">hash_identifier</a>to identify the hash.</li> <br>
                                <p>[ step - 2 ] Search the hash in google</p>
                                <li>Got the hash of admin password, ie : <pre><code>admin</code></pre></li><br>
                                <p>Using online Hash lookup service</p>
                                <li>Using online hash decoder we can serach for commmon hash password.</li>
                                <li>successfully logged in as admin</li><br><br>

                                <h4>Lab 2</h4>
                                <li>Given material --> some user id and hash</li> <br>
                                <p>[ step- 1 ] Identification of the hash</p>
                                
                                <li>the hash is 64 character long</li>
                                <li>most probably the hash is SHA256.</li>
                                <li>we can use <a href="https://hashes.com/en/tools/hash_identifier" target="_blank">hash_identifier</a>to identify the hash.</li> <br>
                                <p>[ step - 2 ] Search the hash in google</p>
                                <li>Didn't got any result</li><br>
                                <p>Using online Hash lookup service and some password cracking tools [ Jhon the ripper ] or [ hashcat ]</p>
                                <li>No result found [ in this case ]</li><br>
                                <p>From the code we can see a custom function is used</p>
                                <li>After reversing the admin hash and searching in online dictionary</li>
                                <li>We get <pre><code>admin</code></pre> is passowrd for admin, this gives use the admin access</li><br>
                                <p>Other solution ( because it quite difficult to guess custom hash function ) :</p>
                                <li>Brute force the login page ( no delay implemented so it would be better idea) using burp, Zed etc.</li><br><br>


                                <h4>Lab 3</h4>
                                <li>Given material --> Normal user credential</li> 
                                <li>admin user name --> unkown, password --> unkown</li>
                                <li>After some observation we will see there is a cookie named cookie with a value "User|2022-07-07 06:24:08.802299" in the format "{username}|{timestamp}"</li>
                                <li>We can chage the cookie value with "Admin|2022-07-07 06:24:08.802299" ( Admin/admin/some other common admin name )</li>
                                <li>after some guessing we got "admin|2022-07-07 06:24:08.802299" is the admin cookie , which gives us admin access.</li><br>
                                
                        <br>
                        <h4>OWASP References</h4>
                        <ul>
                            <li><a href="https://owasp.org/Top10/A02_2021-Cryptographic_Failures/" target="_blank">OWASP Cryptographic Failure</a></li>
                            <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html" target="_blank">OWASP Cryptographic Failure Cheatsheet</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
    </div>
</div>